{"version":3,"sources":["Redux/initialState.js","utilities/index.js","Redux/reducers/tilesReducer.js","Redux/actions.js","Redux/reducers/emptyFieldsReducer.js","Redux/reducers/scoreReducer.js","Redux/reducers/gameReducer.js","Redux/reducers/index.js","Components/Field/index.js","Components/Tile/index.js","Components/TilesField/index.js","Redux/actions/tilesActions.js","Redux/actions/emptiesAction.js","Redux/actions/gameActions.js","Redux/actions/scoreActions.js","Components/StartButton/index.js","Components/Score/index.js","Components/FinishGame/index.js","Components/App/index.js","index.js"],"names":["initialState","tiles","emptyFields","rowPos","colPos","isEmpty","score","currentScore","bestScore","gameStatus","getRandomInt","min","max","Math","floor","random","getRandomArrayItem","array","length","updateLocalEmpties","oldTile","newTile","map","item","tilesReducer","state","action","type","payload","filter","randomEmpty","tileVal","initialTiles","rowPosition","colPosition","find","push","sortedTiles","direction","sort","a","b","updatedTiles","tile","currentRow","currentCol","prevCell","i","nextCell","emptyFieldsReducer","updatedEmpties","scoreReducer","bestScoreValue","currentScoreValue","combineReducers","gameReducer","Field","className","Tile","TilesField","key","defaultProps","connect","dispatch","addTile","updateEmptiesAction","initGameThunkAction","getState","StartButton","initGame","children","onClick","React","memo","undefined","scoreType","scoreLabel","scoreValue","updateTilesPosition","updateTilesPositionAction","updateTilesPositionAThunk","moveLeft","moveRight","moveUp","moveDown","useEffect","document","addEventListener","e","keyCode","onSwipedLeft","onSwipedRight","onSwipedUp","onSwipedDown","persistConfig","storage","composeEnhancers","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","trace","traceLimit","compose","persistedReducer","persistReducer","reducer","store","createStore","applyMiddleware","thunkMiddleware","persistor","persistStore","purge","ReactDOM","render","loading","getElementById"],"mappings":"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","file":"static/js/main.17fc69c9.chunk.js","sourcesContent":["const initialState = {\n  tiles: [],\n  emptyFields: [\n    { rowPos: 1, colPos: 1, isEmpty: true },\n    { rowPos: 1, colPos: 2, isEmpty: true },\n    { rowPos: 1, colPos: 3, isEmpty: true },\n    { rowPos: 1, colPos: 4, isEmpty: true },\n    { rowPos: 2, colPos: 1, isEmpty: true },\n    { rowPos: 2, colPos: 2, isEmpty: true },\n    { rowPos: 2, colPos: 3, isEmpty: true },\n    { rowPos: 2, colPos: 4, isEmpty: true },\n    { rowPos: 3, colPos: 1, isEmpty: true },\n    { rowPos: 3, colPos: 2, isEmpty: true },\n    { rowPos: 3, colPos: 3, isEmpty: true },\n    { rowPos: 3, colPos: 4, isEmpty: true },\n    { rowPos: 4, colPos: 1, isEmpty: true },\n    { rowPos: 4, colPos: 2, isEmpty: true },\n    { rowPos: 4, colPos: 3, isEmpty: true },\n    { rowPos: 4, colPos: 4, isEmpty: true },\n  ],\n  score: {\n    currentScore: 0,\n    bestScore: 0,\n  },\n  gameStatus: false,\n};\n\nexport default initialState;\n","export const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\nexport const getRandomArrayItem = (array) => array[Math.floor(Math.random() * array.length)];\n\nexport const updateLocalEmpties = (emptyFields, oldTile, newTile) => {\n  return emptyFields.map((item) => {\n    if (item.colPos === oldTile.colPos && item.rowPos === oldTile.rowPos) {\n      return {\n        ...item,\n        isEmpty: true,\n      };\n    }\n    if (item.colPos === newTile.colPos && item.rowPos === newTile.rowPos) {\n      return {\n        ...item,\n        isEmpty: false,\n      };\n    }\n    return item;\n  });\n};\n","import { ADD_TILE, ADD_RANDOM_TILE, INIT_FIRST_TILES, UPDATE_POSITION } from '../actions';\nimport initialState from '../initialState';\nimport { getRandomInt, updateLocalEmpties, getRandomArrayItem } from '../../utilities';\n\nconst tilesReducer = (state = initialState.tiles, action) => {\n  switch (action.type) {\n    case ADD_RANDOM_TILE: {\n      const emptyFields = action.payload.filter(({ isEmpty }) => isEmpty === true);\n      const randomEmpty = getRandomArrayItem(emptyFields);\n      if (randomEmpty) {\n        return [\n          ...state,\n          {\n            rowPos: randomEmpty.rowPos,\n            colPos: randomEmpty.colPos,\n            tileVal: getRandomArrayItem([2, 4]),\n          },\n        ];\n      }\n      return state;\n    }\n    case ADD_TILE:\n      return state;\n    case INIT_FIRST_TILES: {\n      const initialTiles = [];\n\n      while (initialTiles.length < 2) {\n        const rowPosition = getRandomInt(1, 4);\n        const colPosition = getRandomInt(1, 4);\n        const tileValue = 2;\n\n        // Check if previous tile was created on the same place\n        const duplicate = initialTiles.find(\n          ({ rowPos, colPos }) => rowPos === rowPosition && colPos === colPosition,\n        );\n\n        if (!duplicate) {\n          initialTiles.push({\n            rowPos: rowPosition,\n            colPos: colPosition,\n            tileVal: tileValue,\n          });\n        }\n      }\n      return initialTiles;\n    }\n\n    // UPDATE_POSITION: moves all the tiles depends on the direction.\n    case UPDATE_POSITION: {\n      // Array of tiles sorts according to the move direction.\n      // It helps to move the right (first) tile first.\n      let sortedTiles = [];\n\n      if (action.payload.direction === 'left' || action.payload.direction === 'up') {\n        sortedTiles = state.sort((a, b) => {\n          if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n          return a.colPos - b.colPos;\n        });\n      }\n\n      if (action.payload.direction === 'right') {\n        sortedTiles = state.sort((a, b) => {\n          if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n          return b.colPos - a.colPos;\n        });\n      }\n\n      if (action.payload.direction === 'down') {\n        sortedTiles = state.sort((a, b) => {\n          if (a.rowPos !== b.rowPos) return b.rowPos - a.rowPos;\n          return a.colPos - b.colPos;\n        });\n      }\n\n      // Save the local empties\n      let { emptyFields } = action.payload;\n\n      const updatedTiles = sortedTiles.map((tile) => {\n        // switch is using cols or rows depend on the direction for every tile\n        const currentRow = emptyFields.filter(\n          ({ rowPos }) => rowPos === tile.rowPos,\n        );\n        const currentCol = emptyFields.filter(\n          ({ colPos }) => colPos === tile.colPos,\n        );\n        switch (action.payload.direction) {\n          case 'left': {\n            // Get the last possible FREE position for the tile in row to the left from its position\n            let prevCell = tile.colPos;\n            // -1 for the prev cell and -1 for the array iterator\n            let i = prevCell - 2 < 0 ? 0 : prevCell - 2;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i >= 0; i -= 1) {\n              if (currentRow[i].colPos !== tile.colPos && currentRow[i].isEmpty) {\n                prevCell = currentRow[i].colPos;\n              } else {\n                break;\n              }\n            }\n            // If there is a position and it's not the same that tile have\n            if (prevCell && prevCell !== tile.colPos) {\n              // Update empties depends on the new tile position\n              emptyFields = updateLocalEmpties(\n                emptyFields, tile, { rowPos: tile.rowPos, colPos: prevCell },\n              );\n              // Add new position for the tile\n              return {\n                ...tile,\n                colPos: prevCell,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          case 'right': {\n            // Get the last possible FREE position for the tile in row to the right from its position\n            let nextCell = tile.colPos;\n            // Index to start search\n            let i = nextCell;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i < 4; i += 1) {\n              if (currentRow[i].colPos !== tile.colPos && currentRow[i].isEmpty) {\n                nextCell = currentRow[i].colPos;\n              } else {\n                break;\n              }\n            }\n            // Update empties depends on the new tile position\n            if (nextCell && nextCell !== tile.colPos) {\n              emptyFields = updateLocalEmpties(\n                emptyFields, tile, { rowPos: tile.rowPos, colPos: nextCell },\n              );\n              // Add new position for the tile\n              return {\n                ...tile,\n                colPos: nextCell,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          case 'up': {\n            // Get the last possible FREE position for the tile in row above its position\n            let prevCell = tile.rowPos;\n            // -1 for the prev cell and -1 for the array iterator\n            let i = prevCell - 2 < 0 ? 0 : prevCell - 2;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i >= 0; i -= 1) {\n              if (currentCol[i].rowPos !== tile.rowPos && currentCol[i].isEmpty) {\n                prevCell = currentCol[i].rowPos;\n              } else {\n                break;\n              }\n            }\n            // Update empties depends on the new tile position\n            if (prevCell && prevCell !== tile.rowPos) {\n              emptyFields = updateLocalEmpties(\n                emptyFields, tile, { rowPos: prevCell, colPos: tile.colPos },\n              );\n              // Add new position for the tile\n              return {\n                ...tile,\n                rowPos: prevCell,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          case 'down': {\n            // Get the last possible FREE position for the tile in row below its position\n            let nextCell = tile.rowPos;\n            // -1 for the prev cell and -1 for the array iterator\n            let i = nextCell;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i < 4; i += 1) {\n              if (currentCol[i].rowPos !== tile.rowPos && currentCol[i].isEmpty) {\n                nextCell = currentCol[i].rowPos;\n              } else {\n                break;\n              }\n            }\n            // Update empties depends on the new tile position\n            if (nextCell && nextCell !== tile.rowPos) {\n              emptyFields = updateLocalEmpties(\n                emptyFields, tile, { rowPos: nextCell, colPos: tile.colPos },\n              );\n              // Add new position for the tile\n              return {\n                ...tile,\n                rowPos: nextCell,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          default:\n            return tile;\n        }\n      });\n      return updatedTiles;\n    }\n    default:\n      return state;\n  }\n};\n\nexport default tilesReducer;\n","// Game actions\nexport const INIT_GAME = 'INIT_GAME';\nexport const FINISH_GAME = 'FINISH_GAME';\n\n// Empties actions\nexport const UPDATE_EMPTIES = 'UPDATE_EMPTIES';\nexport const INIT_EMPTIES = 'INIT_EMPTIES';\n\n// Tiles actions\nexport const UPDATE_POSITION = 'UPDATE_POSITION';\nexport const REMOVE_NUMBER = 'REMOVE_NUMBER';\nexport const ADD_TILE = 'ADD_TILE';\nexport const ADD_RANDOM_TILE = 'ADD_RANDOM_TILE';\nexport const INIT_FIRST_TILES = 'INIT_FIRST_TILES';\n\n// Score actions\nexport const UPDATE_SCORE = 'UPDATE_SCORE';\nexport const CLEAR_CURRENT_SCORE = 'CLEAR_CURRENT_SCORE';\n","import { UPDATE_EMPTIES, INIT_EMPTIES } from '../actions';\nimport initialState from '../initialState';\n\nconst emptyFieldsReducer = (state = initialState.emptyFields, action) => {\n  switch (action.type) {\n    // UPDATE_EMPTIES: returns array of updated empty fields related to the sent tile.\n    // Find fields with old and new tile position.\n    // Set oldPosition.isEmpty to true, newPosition.isEmpty to false.\n    case UPDATE_EMPTIES: {\n      const tiles = action.payload;\n      const updatedEmpties = state.map((item) => {\n        const tile = tiles.find(\n          ({ rowPos, colPos }) => rowPos === item.rowPos && colPos === item.colPos,\n        );\n        if (tile) return { ...item, isEmpty: false };\n        return {\n          ...item,\n          isEmpty: true,\n        };\n      });\n      return updatedEmpties;\n    }\n    // INIT_EMPTIES: sets emptyFields to the default value.\n    case INIT_EMPTIES:\n      return initialState.emptyFields;\n    default:\n      return state;\n  }\n};\n\nexport default emptyFieldsReducer;\n","import { UPDATE_SCORE, CLEAR_CURRENT_SCORE } from '../actions';\nimport initialState from '../initialState';\n\nconst scoreReducer = (state = initialState.score, action) => {\n  switch (action.type) {\n    case UPDATE_SCORE: {\n      let bestScoreValue = state.bestScore;\n      const currentScoreValue = state.currentScore + action.payload;\n      if (!bestScoreValue) {\n        bestScoreValue = action.payload;\n      } else {\n        bestScoreValue = Math.max(\n          currentScoreValue,\n          bestScoreValue,\n        );\n      }\n      return {\n        ...state,\n        currentScore: currentScoreValue,\n        bestScore: bestScoreValue,\n      };\n    }\n    case CLEAR_CURRENT_SCORE:\n      return {\n        ...state,\n        currentScore: initialState.score.currentScore,\n      };\n    default:\n      return state;\n  }\n};\n\nexport default scoreReducer;\n","import { INIT_GAME, FINISH_GAME } from '../actions';\nimport initialState from '../initialState';\n\nconst emptyFieldsReducer = (state = initialState.gameStatus, action) => {\n  switch (action.type) {\n    case INIT_GAME:\n      return true;\n    case FINISH_GAME:\n      return false;\n    default:\n      return state;\n  }\n};\n\nexport default emptyFieldsReducer;\n","import { combineReducers } from 'redux';\nimport tilesReducer from './tilesReducer';\nimport emptyFieldsReducer from './emptyFieldsReducer';\nimport scoreReducer from './scoreReducer';\nimport gameReducer from './gameReducer';\n\nexport default combineReducers({\n  tiles: tilesReducer,\n  emptyFields: emptyFieldsReducer,\n  score: scoreReducer,\n  gameStatus: gameReducer,\n});\n","import React from 'react';\n\n// CSS\nimport './styles.css';\n\nconst Field = () => (\n  <div className=\"grid\">\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n  </div>\n);\n\nexport default Field;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\nconst Tile = ({ tileVal, rowPos, colPos }) => <div className={`number number--${tileVal} pos--${rowPos}-${colPos}`}>{tileVal}</div>;\n\nTile.propTypes = {\n  tileVal: PropTypes.number.isRequired,\n  rowPos: PropTypes.number.isRequired,\n  colPos: PropTypes.number.isRequired,\n};\n\nexport default Tile;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\n// redux\nimport { connect } from 'react-redux';\nimport { addTileAction } from '../../Redux/actions/tilesActions';\n\n// Components\nimport Tile from '../Tile';\n\nconst TilesField = ({ tiles }) => (\n  <div className=\"grid numbers\">\n    { tiles.map((tile) => <Tile key={`${tile.rowPos}-${tile.colPos}`} rowPos={tile.rowPos} colPos={tile.colPos} tileVal={tile.tileVal} />) }\n  </div>\n);\n\nTilesField.propTypes = {\n  tiles: PropTypes.arrayOf(PropTypes.objectOf(PropTypes.number)),\n};\n\nTilesField.defaultProps = {\n  tiles: [],\n};\n\nconst mapStateToProps = (state) => ({ tiles: state.tiles });\nconst mapDispatchToProps = (dispatch) => ({\n  addTile: (rowPos, colPos, tileVal) => dispatch(addTileAction(rowPos, colPos, tileVal)),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TilesField);\n","import {\n  ADD_RANDOM_TILE, ADD_TILE, INIT_FIRST_TILES,\n  UPDATE_POSITION,\n} from '../actions';\n\nexport const addTileAction = () => ({ type: ADD_TILE });\n\nexport const initTilesAction = () => ({ type: INIT_FIRST_TILES });\n\nexport const addRandomTileAction = (emptyFields) => ({\n  type: ADD_RANDOM_TILE,\n  payload: emptyFields,\n});\n\nexport const updateTilesPositionAction = (direction, emptyFields) => ({\n  type: UPDATE_POSITION,\n  payload: {\n    direction,\n    emptyFields,\n  },\n});\n","import { INIT_EMPTIES, UPDATE_EMPTIES } from '../actions';\n\nexport const initEmptiesAction = () => ({ type: INIT_EMPTIES });\nexport const updateEmptiesAction = (tiles) => ({ type: UPDATE_EMPTIES, payload: tiles });\n","import { INIT_GAME, FINISH_GAME } from '../actions';\nimport { initTilesAction, updateTilesPositionAction, addRandomTileAction } from './tilesActions';\nimport { clearScoreAction } from './scoreActions';\nimport { updateEmptiesAction, initEmptiesAction } from './emptiesAction';\n\nconst initGameAction = () => ({ type: INIT_GAME });\nconst finishGameAction = () => ({ type: FINISH_GAME });\n\nexport const initGameThunkAction = () => (dispatch, getState) => {\n  dispatch(initGameAction());\n  dispatch(clearScoreAction());\n  dispatch(initEmptiesAction());\n  dispatch(initTilesAction());\n  dispatch(updateEmptiesAction(getState().tiles));\n};\n\nexport const updateTilesPositionAThunk = (direction) => (dispatch, getState) => {\n  dispatch(updateTilesPositionAction(direction, getState().emptyFields));\n  dispatch(updateEmptiesAction(getState().tiles));\n  dispatch(addRandomTileAction(getState().emptyFields));\n  dispatch(updateEmptiesAction(getState().tiles));\n  // check game status\n  const freeEmpties = getState().emptyFields.filter(({ isEmpty }) => isEmpty);\n  if (!freeEmpties.length) {\n    dispatch(finishGameAction());\n  }\n};\n\n\n","import { UPDATE_SCORE, CLEAR_CURRENT_SCORE } from '../actions';\n\nexport const updateScoreAction = (currentScore) => ({\n  type: UPDATE_SCORE,\n  payload: currentScore,\n});\n\nexport const clearScoreAction = () => ({ type: CLEAR_CURRENT_SCORE });\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\n// redux\nimport { connect } from 'react-redux';\nimport { initGameThunkAction } from '../../Redux/actions/gameActions';\n\nconst StartButton = ({ initGame, children }) => <button type=\"button\" className=\"start-button\" onClick={initGame}>{ children }</button>;\n\nStartButton.propTypes = {\n  initGame: PropTypes.func.isRequired,\n  children: PropTypes.string,\n};\n\nStartButton.defaultProps = {\n  children: 'Start again',\n};\n\nconst mapDispatchToProps = (dispatch) => ({\n  initGame: () => dispatch(initGameThunkAction()),\n});\n\nexport default React.memo(connect(undefined, mapDispatchToProps)(StartButton));\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\n// redux\nimport { connect } from 'react-redux';\n\nconst Score = ({ score, scoreType }) => {\n  const scoreLabel = scoreType === 'current' ? 'Your score' : 'Best score';\n  const scoreValue = scoreType === 'current' ? score.currentScore : score.bestScore;\n\n  return (\n    <div className=\"score\">\n      <span className=\"score__label\">{scoreLabel}</span>\n      <span className=\"score__value\">{scoreValue}</span>\n    </div>\n  );\n};\n\nScore.propTypes = {\n  score: PropTypes.objectOf(PropTypes.number).isRequired,\n  scoreType: PropTypes.string.isRequired,\n};\n\nconst mapStateToProps = (state) => ({ score: state.score });\n\nexport default React.memo(connect(mapStateToProps)(Score));\n","import React from 'react';\n\n// CSS\nimport './styles.css';\n\nimport StartButton from '../StartButton';\n\nconst FinishGame = () => (\n  <div className=\"game-status\">\n    END GAME\n    <StartButton>Restart</StartButton>\n  </div>\n);\n\nexport default React.memo(FinishGame);\n","import React, { useEffect } from 'react';\nimport { Swipeable } from 'react-swipeable';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\n// components\nimport { connect } from 'react-redux';\nimport Field from '../Field';\nimport TilesField from '../TilesField';\nimport StartButton from '../StartButton';\nimport Score from '../Score';\n\n// Actions\nimport { initGameThunkAction, updateTilesPositionAThunk } from '../../Redux/actions/gameActions';\nimport FinishGame from '../FinishGame';\n\n// const App = ({ /*tiles, updateTilePosition*/ }) => {\nconst App = ({ initGame, updateTilesPosition, gameStatus }) => {\n  const moveLeft = () => {\n    updateTilesPosition('left');\n  };\n\n  const moveRight = () => {\n    updateTilesPosition('right');\n  };\n\n  const moveUp = () => {\n    updateTilesPosition('up');\n  };\n\n  const moveDown = () => {\n    updateTilesPosition('down');\n  };\n\n  useEffect(() => {\n    initGame();\n\n    document.addEventListener('keydown', (e) => {\n      switch (e.keyCode) {\n        case 37:\n          moveLeft();\n          break;\n        case 38:\n          moveUp();\n          break;\n        case 39:\n          moveRight();\n          break;\n        case 40:\n          moveDown();\n          break;\n        default:\n      }\n    });\n  }, []);\n\n  return (\n    <Swipeable\n      onSwipedLeft={moveLeft}\n      onSwipedRight={moveRight}\n      onSwipedUp={moveUp}\n      onSwipedDown={moveDown}\n      className=\"wrap\"\n    >\n      <h1 className=\"game-header\">2048</h1>\n      <p className=\"game-description\">Use Up, Down, Left, Right keys or swipe to play</p>\n      <StartButton />\n      <div className=\"score-wrap\">\n        <Score scoreType=\"current\" />\n        <Score scoreType=\"best\" />\n      </div>\n      <div className=\"game__container\">\n        <Field />\n        <TilesField />\n        { !gameStatus ? <FinishGame /> : null }\n      </div>\n    </Swipeable>\n  );\n};\n\nApp.propTypes = {\n  gameStatus: PropTypes.bool.isRequired,\n  initGame: PropTypes.func.isRequired,\n  updateTilesPosition: PropTypes.func.isRequired,\n};\n\nconst mapStateToProps = (state) => ({ tiles: state.tiles, gameStatus: state.gameStatus });\n\nconst mapDispatchToProps = (dispatch) => ({\n  initGame: () => dispatch(initGameThunkAction()),\n  updateTilesPosition: (direction) => dispatch(updateTilesPositionAThunk(direction)),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\n// CSS\nimport './css/variables.css';\nimport './css/common.css';\n\n// redux\nimport { applyMiddleware, compose, createStore } from 'redux';\nimport { Provider } from 'react-redux';\nimport thunkMiddleware from 'redux-thunk';\n\n// redux-persist\nimport { persistStore, persistReducer } from 'redux-persist';\nimport { PersistGate } from 'redux-persist/integration/react';\nimport storage from 'redux-persist/lib/storage';\nimport reducer from './Redux/reducers';\n\nimport App from './Components/App';\n\nconst persistConfig = {\n  key: 'root',\n  storage,\n};\n\nconst composeEnhancers = (\n  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n  && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({ trace: true, traceLimit: 25 })\n) || compose;\n\nconst persistedReducer = persistReducer(persistConfig, reducer);\nconst store = createStore(\n  persistedReducer,\n  composeEnhancers(applyMiddleware(thunkMiddleware)),\n);\n\nconst persistor = persistStore(store);\n\npersistor.purge(); // CLEAR redux-persist cache\n\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate persistor={persistor} loading={null}>\n      <App />\n    </PersistGate>\n  </Provider>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}