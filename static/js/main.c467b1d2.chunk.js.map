{"version":3,"sources":["Redux/initialState.js","utilities/index.js","Redux/reducers/tilesReducer.js","Redux/actions.js","Redux/reducers/emptyFieldsReducer.js","Redux/reducers/scoreReducer.js","Redux/reducers/gameReducer.js","Redux/reducers/index.js","Components/Field/index.js","Components/Tile/index.js","Components/TilesField/index.js","Redux/actions/emptiesAction.js","Redux/actions/gameActions.js","Redux/actions/scoreActions.js","Redux/actions/tilesActions.js","Components/StartButton/index.js","Components/Score/index.js","Components/FinishGame/index.js","Components/App/index.js","index.js"],"names":["initialState","tiles","emptyFields","rowPos","colPos","isEmpty","score","currentScore","bestScore","gameStatus","getRandomInt","min","max","Math","floor","random","getRandomArrayItem","array","length","updateLocalEmpties","oldTile","newTile","map","item","emptyField","isMerged","tileVal","sortTilesForMove","direction","sort","a","b","tilesReducer","state","action","type","payload","filter","randomEmpty","initialTiles","rowPosition","colPosition","find","push","sortedTiles","tilesForRemove","updatedTiles","tile","currentRow","currentCol","prevCell","i","isTileMerged","newTileValue","tileForMergePos","tileForMerge","nextCell","removedVal","emptyFieldsReducer","updatedEmpties","scoreReducer","bestScoreValue","currentScoreValue","combineReducers","gameReducer","Field","className","Tile","TilesField","key","defaultProps","connect","updateEmptiesAction","initGameThunkAction","dispatch","getState","StartButton","initGame","children","onClick","React","memo","undefined","scoreType","scoreLabel","scoreValue","updateTilesPosition","updateTilesPositionAction","updateTilesPositionAThunk","moveLeft","moveRight","moveUp","moveDown","useEffect","document","addEventListener","e","keyCode","onSwipedLeft","onSwipedRight","onSwipedUp","onSwipedDown","persistConfig","storage","composeEnhancers","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","trace","traceLimit","compose","persistedReducer","persistReducer","reducer","store","createStore","applyMiddleware","thunkMiddleware","persistor","persistStore","purge","ReactDOM","render","loading","getElementById"],"mappings":"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","file":"static/js/main.c467b1d2.chunk.js","sourcesContent":["const initialState = {\n  tiles: [],\n  emptyFields: [\n    { rowPos: 1, colPos: 1, isEmpty: true },\n    { rowPos: 1, colPos: 2, isEmpty: true },\n    { rowPos: 1, colPos: 3, isEmpty: true },\n    { rowPos: 1, colPos: 4, isEmpty: true },\n    { rowPos: 2, colPos: 1, isEmpty: true },\n    { rowPos: 2, colPos: 2, isEmpty: true },\n    { rowPos: 2, colPos: 3, isEmpty: true },\n    { rowPos: 2, colPos: 4, isEmpty: true },\n    { rowPos: 3, colPos: 1, isEmpty: true },\n    { rowPos: 3, colPos: 2, isEmpty: true },\n    { rowPos: 3, colPos: 3, isEmpty: true },\n    { rowPos: 3, colPos: 4, isEmpty: true },\n    { rowPos: 4, colPos: 1, isEmpty: true },\n    { rowPos: 4, colPos: 2, isEmpty: true },\n    { rowPos: 4, colPos: 3, isEmpty: true },\n    { rowPos: 4, colPos: 4, isEmpty: true },\n  ],\n  score: {\n    currentScore: 0,\n    bestScore: 0,\n  },\n  gameStatus: false,\n};\n\nexport default initialState;\n","export const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\nexport const getRandomArrayItem = (array) => array[Math.floor(Math.random() * array.length)];\n\nexport const updateLocalEmpties = (emptyFields, oldTile, newTile) => emptyFields.map((item) => {\n  let emptyField = item;\n  if (item.colPos === oldTile.colPos && item.rowPos === oldTile.rowPos) {\n    emptyField = {\n      ...emptyField,\n      isEmpty: true,\n    };\n  }\n  if (item.colPos === newTile.colPos && item.rowPos === newTile.rowPos) {\n    emptyField = {\n      ...emptyField,\n      isEmpty: false,\n      isMerged: newTile.isMerged,\n      tileVal: newTile.tileVal,\n    };\n  }\n  return emptyField;\n});\n\nexport const sortTilesForMove = (direction, tiles) => {\n  switch (direction) {\n    case 'left': {\n      return tiles.sort((a, b) => {\n        if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n        return a.colPos - b.colPos;\n      });\n    }\n    case 'right': {\n      return tiles.sort((a, b) => {\n        if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n        return b.colPos - a.colPos;\n      });\n    }\n    case 'up': {\n      return tiles.sort((a, b) => {\n        if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n        return a.colPos - b.colPos;\n      });\n    }\n    case 'down': {\n      return tiles.sort((a, b) => {\n        if (a.rowPos !== b.rowPos) return b.rowPos - a.rowPos;\n        return a.colPos - b.colPos;\n      });\n    }\n    default:\n      return [];\n  }\n};\n","import { ADD_RANDOM_TILE, INIT_FIRST_TILES, UPDATE_POSITION } from '../actions';\nimport initialState from '../initialState';\nimport {\n  getRandomInt, getRandomArrayItem,\n  sortTilesForMove, updateLocalEmpties,\n} from '../../utilities';\n\nconst tilesReducer = (state = initialState.tiles, action) => {\n  switch (action.type) {\n    case ADD_RANDOM_TILE: {\n      const emptyFields = action.payload.filter(({ isEmpty }) => isEmpty === true);\n      const randomEmpty = getRandomArrayItem(emptyFields);\n      if (randomEmpty) {\n        return [\n          ...state,\n          {\n            rowPos: randomEmpty.rowPos,\n            colPos: randomEmpty.colPos,\n            tileVal: getRandomArrayItem([2, 4]),\n          },\n        ];\n      }\n      return state;\n    }\n    case INIT_FIRST_TILES: {\n      const initialTiles = [];\n\n      while (initialTiles.length < 2) {\n        const rowPosition = getRandomInt(1, 4);\n        const colPosition = getRandomInt(1, 4);\n        const tileValue = 2;\n\n        // Check if previous tile was created on the same place\n        const duplicate = initialTiles.find(\n          ({ rowPos, colPos }) => rowPos === rowPosition && colPos === colPosition,\n        );\n\n        if (!duplicate) {\n          initialTiles.push({\n            rowPos: rowPosition,\n            colPos: colPosition,\n            tileVal: tileValue,\n          });\n        }\n      }\n      return initialTiles;\n    }\n    // UPDATE_POSITION: moves and merge (if possible) all the tiles depends on the direction.\n    case UPDATE_POSITION: {\n      // Array of tiles sorts according to the move direction.\n      // It helps to move the right (first) tile first.\n      const sortedTiles = sortTilesForMove(action.payload.direction, state);\n      const tilesForRemove = [];\n\n      // Save the local empties, reset isMerged for this move\n      let emptyFields = action.payload.emptyFields.map(\n        (emptyField) => ({ ...emptyField, isMerged: false }),\n      );\n\n      const updatedTiles = sortedTiles.map((tile) => {\n        // switch is using cols or rows depend on the direction for every tile\n        const currentRow = emptyFields.filter(\n          ({ rowPos }) => rowPos === tile.rowPos,\n        );\n        const currentCol = emptyFields.filter(\n          ({ colPos }) => colPos === tile.colPos,\n        );\n        switch (action.payload.direction) {\n          case 'left': {\n            // Get the last possible FREE position for the tile in row to the left from its position\n            let prevCell = tile.colPos;\n            // -1 for the prev cell and -1 for the array iterator\n            let i = prevCell - 2 < 0 ? 0 : prevCell - 2;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i >= 0; i -= 1) {\n              if (currentRow[i].colPos !== tile.colPos && currentRow[i].isEmpty) {\n                prevCell = currentRow[i].colPos;\n              } else {\n                break;\n              }\n            }\n            // If there is a position and it's not the same that tile have\n            if (prevCell) {\n              let isTileMerged = false;\n              // set new tile default value\n              let newTileValue = tile.tileVal;\n              // set position to the next cell after the cell to move tile\n              // to check the next cell is the same tile or not\n              const tileForMergePos = prevCell - 1;\n              // check if the next cell is not empty\n              const tileForMerge = emptyFields.find(\n                ({\n                  rowPos, colPos, isEmpty,\n                  isMerged,\n                }) => (\n                  colPos === tileForMergePos && rowPos === tile.rowPos\n                  && !isEmpty && !isMerged\n                ),\n              );\n\n              // if tile for merge was found and it's value the same as current tile\n              if (tileForMerge && tileForMerge.tileVal === tile.tileVal) {\n                // merged tile will me removed from state\n                tilesForRemove.push({\n                  rowPos: tileForMerge.rowPos,\n                  colPos: tileForMerge.colPos,\n                  tileVal: tileForMerge.tileVal,\n                });\n                // if tile was merged - set new tile position\n                prevCell = tileForMergePos;\n                // if tile was merged - set new tile value\n                newTileValue = tile.tileVal * 2;\n                isTileMerged = true;\n              }\n\n              // update local empties based on the new tile\n              emptyFields = updateLocalEmpties(\n                emptyFields,\n                tile,\n                {\n                  rowPos: tile.rowPos,\n                  colPos: prevCell,\n                  tileVal: newTileValue,\n                  isMerged: isTileMerged,\n                },\n              );\n\n              // Add new position and value (if was merged or default) for the tile\n              return {\n                ...tile,\n                colPos: prevCell,\n                tileVal: newTileValue,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          case 'right': {\n            // Get the last possible FREE position\n            // for the tile in row to the right from its position\n            let nextCell = tile.colPos;\n            // Index to start search\n            let i = nextCell;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i < 4; i += 1) {\n              if (currentRow[i].colPos !== tile.colPos && currentRow[i].isEmpty) {\n                nextCell = currentRow[i].colPos;\n              } else {\n                break;\n              }\n            }\n            // Update empties depends on the new tile position\n            if (nextCell) {\n              let isTileMerged = false;\n              // set new tile default value\n              let newTileValue = tile.tileVal;\n              // set position to the next cell after the cell to move tile\n              // to check the next cell is the same tile or not\n              const tileForMergePos = nextCell + 1;\n              // check if the next cell is not empty\n              const tileForMerge = emptyFields.find(\n                ({\n                  rowPos, colPos, isEmpty,\n                  isMerged,\n                }) => (\n                  colPos === tileForMergePos && rowPos === tile.rowPos\n                  && !isEmpty && !isMerged\n                ),\n              );\n\n              // if tile for merge was found and it's value the same as current tile\n              if (tileForMerge && tileForMerge.tileVal === tile.tileVal) {\n                // merged tile will me removed from state\n                tilesForRemove.push({\n                  rowPos: tileForMerge.rowPos,\n                  colPos: tileForMerge.colPos,\n                  tileVal: tileForMerge.tileVal,\n                });\n                // if tile was merged - set new tile position\n                nextCell = tileForMergePos;\n                // if tile was merged - set new tile value\n                newTileValue = tile.tileVal * 2;\n                isTileMerged = true;\n              }\n\n              // update local empties based on the new tile\n              emptyFields = updateLocalEmpties(\n                emptyFields,\n                tile,\n                {\n                  rowPos: tile.rowPos,\n                  colPos: nextCell,\n                  tileVal: newTileValue,\n                  isMerged: isTileMerged,\n                },\n              );\n\n              // Add new position and value (if was merged or default) for the tile\n              return {\n                ...tile,\n                colPos: nextCell,\n                tileVal: newTileValue,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          case 'up': {\n            // Get the last possible FREE position for the tile in row above its position\n            let prevCell = tile.rowPos;\n            // -1 for the prev cell and -1 for the array iterator\n            let i = prevCell - 2 < 0 ? 0 : prevCell - 2;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i >= 0; i -= 1) {\n              if (currentCol[i].rowPos !== tile.rowPos && currentCol[i].isEmpty) {\n                prevCell = currentCol[i].rowPos;\n              } else {\n                break;\n              }\n            }\n\n            // Update empties depends on the new tile position\n            if (prevCell) {\n              let isTileMerged = false;\n              let newTileValue = tile.tileVal;\n              const tileForMergePos = prevCell - 1;\n              const tileForMerge = emptyFields.find(\n                ({\n                  rowPos, colPos, isEmpty,\n                  isMerged,\n                }) => (\n                  colPos === tile.colPos && rowPos === tileForMergePos && !isEmpty && !isMerged\n                ),\n              );\n\n              if (tileForMerge && tileForMerge.tileVal === tile.tileVal) {\n                tilesForRemove.push({\n                  rowPos: tileForMerge.rowPos,\n                  colPos: tileForMerge.colPos,\n                  tileVal: tileForMerge.tileVal,\n                });\n                prevCell = tileForMergePos;\n                newTileValue = tile.tileVal * 2;\n                isTileMerged = true;\n              }\n\n              emptyFields = updateLocalEmpties(\n                emptyFields,\n                tile,\n                {\n                  rowPos: prevCell,\n                  colPos: tile.colPos,\n                  tileVal: newTileValue,\n                  isMerged: isTileMerged,\n                },\n              );\n\n              // Add new position for the tile\n              return {\n                ...tile,\n                rowPos: prevCell,\n                tileVal: newTileValue,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          case 'down': {\n            // Get the last possible FREE position for the tile in row below its position\n            let nextCell = tile.rowPos;\n            // -1 for the prev cell and -1 for the array iterator\n            let i = nextCell;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i < 4; i += 1) {\n              if (currentCol[i].rowPos !== tile.rowPos && currentCol[i].isEmpty) {\n                nextCell = currentCol[i].rowPos;\n              } else {\n                break;\n              }\n            }\n            // Update empties depends on the new tile position\n            if (nextCell) {\n              let isTileMerged = false;\n              let newTileValue = tile.tileVal;\n              const tileForMergePos = nextCell + 1;\n              const tileForMerge = emptyFields.find(\n                ({\n                  rowPos, colPos, isEmpty,\n                  isMerged,\n                }) => (\n                  colPos === tile.colPos && rowPos === tileForMergePos\n                  && !isEmpty && !isMerged\n                ),\n              );\n\n              if (tileForMerge && tileForMerge.tileVal === tile.tileVal) {\n                tilesForRemove.push({\n                  rowPos: tileForMerge.rowPos,\n                  colPos: tileForMerge.colPos,\n                  tileVal: tileForMerge.tileVal,\n                });\n                nextCell = tileForMergePos;\n                newTileValue = tile.tileVal * 2;\n                isTileMerged = true;\n              }\n\n              emptyFields = updateLocalEmpties(\n                emptyFields,\n                tile,\n                {\n                  rowPos: nextCell,\n                  colPos: tile.colPos,\n                  tileVal: newTileValue,\n                  isMerged: isTileMerged,\n                },\n              );\n\n              // Add new position for the tile\n              return {\n                ...tile,\n                rowPos: nextCell,\n                tileVal: newTileValue,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          default:\n            return tile;\n        }\n      });\n\n      return updatedTiles.filter((tile) => {\n        const removedVal = tilesForRemove.find(({ colPos, rowPos, tileVal }) => (\n          tile.colPos === colPos && tile.rowPos === rowPos && tile.tileVal === tileVal\n        ));\n        if (removedVal) {\n          return tile.rowPos !== removedVal.rowPos && tile.colPos !== removedVal.colPos;\n        }\n        return tile;\n      });\n    }\n    default:\n      return state;\n  }\n};\n\nexport default tilesReducer;\n","// Game actions\nexport const INIT_GAME = 'INIT_GAME';\nexport const FINISH_GAME = 'FINISH_GAME';\n\n// Empties actions\nexport const UPDATE_EMPTIES = 'UPDATE_EMPTIES';\nexport const INIT_EMPTIES = 'INIT_EMPTIES';\n\n// Tiles actions\nexport const UPDATE_POSITION = 'UPDATE_POSITION';\nexport const ADD_RANDOM_TILE = 'ADD_RANDOM_TILE';\nexport const INIT_FIRST_TILES = 'INIT_FIRST_TILES';\n\n// Score actions\nexport const UPDATE_SCORE = 'UPDATE_SCORE';\nexport const CLEAR_CURRENT_SCORE = 'CLEAR_CURRENT_SCORE';\n","import { UPDATE_EMPTIES, INIT_EMPTIES } from '../actions';\nimport initialState from '../initialState';\n\nconst emptyFieldsReducer = (state = initialState.emptyFields, action) => {\n  switch (action.type) {\n    // UPDATE_EMPTIES: returns array of updated empty fields related to the sent tile.\n    // Find fields with old and new tile position.\n    // Set oldPosition.isEmpty to true, newPosition.isEmpty to false.\n    case UPDATE_EMPTIES: {\n      const tiles = action.payload;\n      const updatedEmpties = state.map((item) => {\n        const tile = tiles.find(\n          ({ rowPos, colPos }) => rowPos === item.rowPos && colPos === item.colPos,\n        );\n        if (tile) return { ...item, isEmpty: false };\n        return {\n          ...item,\n          isEmpty: true,\n        };\n      });\n      return updatedEmpties;\n    }\n    // INIT_EMPTIES: sets emptyFields to the default value.\n    case INIT_EMPTIES:\n      return initialState.emptyFields;\n    default:\n      return state;\n  }\n};\n\nexport default emptyFieldsReducer;\n","import { UPDATE_SCORE, CLEAR_CURRENT_SCORE } from '../actions';\nimport initialState from '../initialState';\n\nconst scoreReducer = (state = initialState.score, action) => {\n  switch (action.type) {\n    case UPDATE_SCORE: {\n      let bestScoreValue = state.bestScore;\n      const currentScoreValue = state.currentScore + action.payload;\n      if (!bestScoreValue) {\n        bestScoreValue = action.payload;\n      } else {\n        bestScoreValue = Math.max(\n          currentScoreValue,\n          bestScoreValue,\n        );\n      }\n      return {\n        ...state,\n        currentScore: currentScoreValue,\n        bestScore: bestScoreValue,\n      };\n    }\n    case CLEAR_CURRENT_SCORE:\n      return {\n        ...state,\n        currentScore: initialState.score.currentScore,\n      };\n    default:\n      return state;\n  }\n};\n\nexport default scoreReducer;\n","import { INIT_GAME, FINISH_GAME } from '../actions';\nimport initialState from '../initialState';\n\nconst emptyFieldsReducer = (state = initialState.gameStatus, action) => {\n  switch (action.type) {\n    case INIT_GAME:\n      return true;\n    case FINISH_GAME:\n      return false;\n    default:\n      return state;\n  }\n};\n\nexport default emptyFieldsReducer;\n","import { combineReducers } from 'redux';\nimport tilesReducer from './tilesReducer';\nimport emptyFieldsReducer from './emptyFieldsReducer';\nimport scoreReducer from './scoreReducer';\nimport gameReducer from './gameReducer';\n\nexport default combineReducers({\n  tiles: tilesReducer,\n  emptyFields: emptyFieldsReducer,\n  score: scoreReducer,\n  gameStatus: gameReducer,\n});\n","import React from 'react';\n\n// CSS\nimport './styles.css';\n\nconst Field = () => (\n  <div className=\"grid\">\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n  </div>\n);\n\nexport default Field;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\nconst Tile = ({ tileVal, rowPos, colPos }) => <div className={`number number--${tileVal} pos--${rowPos}-${colPos}`}>{tileVal}</div>;\n\nTile.propTypes = {\n  tileVal: PropTypes.number.isRequired,\n  rowPos: PropTypes.number.isRequired,\n  colPos: PropTypes.number.isRequired,\n};\n\nexport default Tile;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\n// redux\nimport { connect } from 'react-redux';\n\n// Components\nimport Tile from '../Tile';\n\nconst TilesField = ({ tiles }) => (\n  <div className=\"grid numbers\">\n    { tiles.map((tile) => <Tile key={`${tile.rowPos}-${tile.colPos}`} rowPos={tile.rowPos} colPos={tile.colPos} tileVal={tile.tileVal} />) }\n  </div>\n);\n\nTilesField.propTypes = {\n  tiles: PropTypes.arrayOf(PropTypes.objectOf(PropTypes.number)),\n};\n\nTilesField.defaultProps = {\n  tiles: [],\n};\n\nconst mapStateToProps = (state) => ({ tiles: state.tiles });\n\nexport default connect(mapStateToProps)(TilesField);\n","import { INIT_EMPTIES, UPDATE_EMPTIES } from '../actions';\n\nexport const initEmptiesAction = () => ({ type: INIT_EMPTIES });\nexport const updateEmptiesAction = (tiles) => ({ type: UPDATE_EMPTIES, payload: tiles });\n","import { INIT_GAME, FINISH_GAME } from '../actions';\nimport { initTilesAction, updateTilesPositionAction, addRandomTileAction } from './tilesActions';\nimport { clearScoreAction } from './scoreActions';\nimport { updateEmptiesAction, initEmptiesAction } from './emptiesAction';\n\nconst initGameAction = () => ({ type: INIT_GAME });\nconst finishGameAction = () => ({ type: FINISH_GAME });\n\nexport const initGameThunkAction = () => (dispatch, getState) => {\n  dispatch(initGameAction());\n  dispatch(clearScoreAction());\n  dispatch(initEmptiesAction());\n  dispatch(initTilesAction());\n  dispatch(updateEmptiesAction(getState().tiles));\n};\n\nexport const updateTilesPositionAThunk = (direction) => (dispatch, getState) => {\n  dispatch(updateTilesPositionAction(direction, getState().emptyFields));\n  dispatch(updateEmptiesAction(getState().tiles));\n\n  dispatch(addRandomTileAction(getState().emptyFields));\n  dispatch(updateEmptiesAction(getState().tiles));\n\n  // check game status\n  const freeEmpties = getState().emptyFields.filter(({ isEmpty }) => isEmpty);\n  if (!freeEmpties.length) {\n    dispatch(finishGameAction());\n  }\n};\n","import { UPDATE_SCORE, CLEAR_CURRENT_SCORE } from '../actions';\n\nexport const updateScoreAction = (currentScore) => ({\n  type: UPDATE_SCORE,\n  payload: currentScore,\n});\n\nexport const clearScoreAction = () => ({ type: CLEAR_CURRENT_SCORE });\n","import { ADD_RANDOM_TILE, INIT_FIRST_TILES, UPDATE_POSITION } from '../actions';\n\nexport const initTilesAction = () => ({ type: INIT_FIRST_TILES });\n\nexport const addRandomTileAction = (emptyFields) => ({\n  type: ADD_RANDOM_TILE,\n  payload: emptyFields,\n});\n\nexport const updateTilesPositionAction = (direction, emptyFields) => ({\n  type: UPDATE_POSITION,\n  payload: {\n    direction,\n    emptyFields,\n  },\n});\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n// CSS\r\nimport './styles.css';\r\n\r\n// redux\r\nimport { connect } from 'react-redux';\r\nimport { initGameThunkAction } from '../../Redux/actions/gameActions';\r\n\r\nconst StartButton = ({ initGame, children }) => <button type=\"button\" className=\"start-button\" onClick={initGame}>{ children }</button>;\r\n\r\nStartButton.propTypes = {\r\n  initGame: PropTypes.func.isRequired,\r\n  children: PropTypes.string,\r\n};\r\n\r\nStartButton.defaultProps = {\r\n  children: 'Start again',\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => ({\r\n  initGame: () => dispatch(initGameThunkAction()),\r\n});\r\n\r\nexport default React.memo(connect(undefined, mapDispatchToProps)(StartButton));\r\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\n// redux\nimport { connect } from 'react-redux';\n\nconst Score = ({ score, scoreType }) => {\n  const scoreLabel = scoreType === 'current' ? 'Your score' : 'Best score';\n  const scoreValue = scoreType === 'current' ? score.currentScore : score.bestScore;\n\n  return (\n    <div className=\"score\">\n      <span className=\"score__label\">{scoreLabel}</span>\n      <span className=\"score__value\">{scoreValue}</span>\n    </div>\n  );\n};\n\nScore.propTypes = {\n  score: PropTypes.objectOf(PropTypes.number).isRequired,\n  scoreType: PropTypes.string.isRequired,\n};\n\nconst mapStateToProps = (state) => ({ score: state.score });\n\nexport default React.memo(connect(mapStateToProps)(Score));\n","import React from 'react';\r\n\r\n// CSS\r\nimport './styles.css';\r\n\r\nimport StartButton from '../StartButton';\r\n\r\nconst FinishGame = () => (\r\n  <div className=\"game-status\">\r\n    END GAME\r\n    <StartButton>Restart</StartButton>\r\n  </div>\r\n);\r\n\r\nexport default React.memo(FinishGame);\r\n","import React, { useEffect } from 'react';\nimport { Swipeable } from 'react-swipeable';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\n// components\nimport { connect } from 'react-redux';\nimport Field from '../Field';\nimport TilesField from '../TilesField';\nimport StartButton from '../StartButton';\nimport Score from '../Score';\n\n// Actions\nimport { initGameThunkAction, updateTilesPositionAThunk } from '../../Redux/actions/gameActions';\nimport FinishGame from '../FinishGame';\n\nconst App = ({ initGame, updateTilesPosition, gameStatus }) => {\n  const moveLeft = () => {\n    updateTilesPosition('left');\n  };\n\n  const moveRight = () => {\n    updateTilesPosition('right');\n  };\n\n  const moveUp = () => {\n    updateTilesPosition('up');\n  };\n\n  const moveDown = () => {\n    updateTilesPosition('down');\n  };\n\n  useEffect(() => {\n    initGame();\n\n    document.addEventListener('keydown', (e) => {\n      switch (e.keyCode) {\n        case 37:\n          moveLeft();\n          break;\n        case 38:\n          moveUp();\n          break;\n        case 39:\n          moveRight();\n          break;\n        case 40:\n          moveDown();\n          break;\n        default:\n      }\n    });\n  }, []);\n\n  return (\n    <Swipeable\n      onSwipedLeft={moveLeft}\n      onSwipedRight={moveRight}\n      onSwipedUp={moveUp}\n      onSwipedDown={moveDown}\n      className=\"wrap\"\n    >\n      <h1 className=\"game-header\">2048</h1>\n      <p className=\"game-description\">Use Up, Down, Left, Right keys or swipe to play</p>\n      <StartButton />\n      <div className=\"score-wrap\">\n        <Score scoreType=\"current\" />\n        <Score scoreType=\"best\" />\n      </div>\n      <div className=\"game__container\">\n        <Field />\n        <TilesField />\n        { !gameStatus ? <FinishGame /> : null }\n      </div>\n    </Swipeable>\n  );\n};\n\nApp.propTypes = {\n  gameStatus: PropTypes.bool.isRequired,\n  initGame: PropTypes.func.isRequired,\n  updateTilesPosition: PropTypes.func.isRequired,\n};\n\nconst mapStateToProps = (state) => ({ tiles: state.tiles, gameStatus: state.gameStatus });\n\nconst mapDispatchToProps = (dispatch) => ({\n  initGame: () => dispatch(initGameThunkAction()),\n  updateTilesPosition: (direction) => dispatch(updateTilesPositionAThunk(direction)),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\n// CSS\nimport './css/variables.css';\nimport './css/common.css';\n\n// redux\nimport { applyMiddleware, compose, createStore } from 'redux';\nimport { Provider } from 'react-redux';\nimport thunkMiddleware from 'redux-thunk';\n\n// redux-persist\nimport { persistStore, persistReducer } from 'redux-persist';\nimport { PersistGate } from 'redux-persist/integration/react';\nimport storage from 'redux-persist/lib/storage';\nimport reducer from './Redux/reducers';\n\nimport App from './Components/App';\n\nconst persistConfig = {\n  key: 'root',\n  storage,\n};\n\nconst composeEnhancers = (\n  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n  && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({ trace: true, traceLimit: 25 })\n) || compose;\n\nconst persistedReducer = persistReducer(persistConfig, reducer);\nconst store = createStore(\n  persistedReducer,\n  composeEnhancers(applyMiddleware(thunkMiddleware)),\n);\n\nconst persistor = persistStore(store);\n\npersistor.purge(); // CLEAR redux-persist cache\n\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate persistor={persistor} loading={null}>\n      <App />\n    </PersistGate>\n  </Provider>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}