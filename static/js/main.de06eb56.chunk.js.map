{"version":3,"sources":["Redux/initialState.js","utilities/index.js","Redux/reducers/tilesReducer.js","Redux/actions.js","Redux/reducers/emptyFieldsReducer.js","Redux/reducers/scoreReducer.js","Redux/reducers/gameReducer.js","Redux/reducers/index.js","Components/Field/index.js","Components/Tile/index.js","Components/TilesField/index.js","Redux/actions/emptiesAction.js","Redux/actions/gameActions.js","Redux/actions/scoreActions.js","Redux/actions/tilesActions.js","Components/StartButton/index.js","Components/Score/index.js","Components/FinishGame/index.js","Components/App/index.js","index.js"],"names":["initialState","tiles","emptyFields","rowPos","colPos","isEmpty","score","currentScore","bestScore","gameStatus","getRandomInt","min","max","Math","floor","random","getRandomArrayItem","array","length","updateLocalEmpties","oldTile","newTile","map","item","emptyField","tileVal","sortTilesForMove","direction","sort","a","b","tilesReducer","state","action","type","payload","filter","randomEmpty","initialTiles","rowPosition","colPosition","find","push","sortedTiles","tilesForRemove","updatedTiles","tile","currentRow","currentCol","prevCell","i","newTileValue","tileForMergePos","tileForMerge","nextCell","removedVal","emptyFieldsReducer","updatedEmpties","scoreReducer","bestScoreValue","currentScoreValue","combineReducers","gameReducer","Field","className","Tile","TilesField","key","defaultProps","connect","updateEmptiesAction","initGameThunkAction","dispatch","getState","StartButton","initGame","children","onClick","React","memo","undefined","scoreType","scoreLabel","scoreValue","updateTilesPosition","updateTilesPositionAction","updateTilesPositionAThunk","moveLeft","moveRight","moveUp","moveDown","useEffect","document","addEventListener","e","keyCode","onSwipedLeft","onSwipedRight","onSwipedUp","onSwipedDown","persistConfig","storage","composeEnhancers","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","trace","traceLimit","compose","persistedReducer","persistReducer","reducer","store","createStore","applyMiddleware","thunkMiddleware","persistor","persistStore","purge","ReactDOM","render","loading","getElementById"],"mappings":"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","file":"static/js/main.de06eb56.chunk.js","sourcesContent":["const initialState = {\n  tiles: [],\n  emptyFields: [\n    { rowPos: 1, colPos: 1, isEmpty: true },\n    { rowPos: 1, colPos: 2, isEmpty: true },\n    { rowPos: 1, colPos: 3, isEmpty: true },\n    { rowPos: 1, colPos: 4, isEmpty: true },\n    { rowPos: 2, colPos: 1, isEmpty: true },\n    { rowPos: 2, colPos: 2, isEmpty: true },\n    { rowPos: 2, colPos: 3, isEmpty: true },\n    { rowPos: 2, colPos: 4, isEmpty: true },\n    { rowPos: 3, colPos: 1, isEmpty: true },\n    { rowPos: 3, colPos: 2, isEmpty: true },\n    { rowPos: 3, colPos: 3, isEmpty: true },\n    { rowPos: 3, colPos: 4, isEmpty: true },\n    { rowPos: 4, colPos: 1, isEmpty: true },\n    { rowPos: 4, colPos: 2, isEmpty: true },\n    { rowPos: 4, colPos: 3, isEmpty: true },\n    { rowPos: 4, colPos: 4, isEmpty: true },\n  ],\n  score: {\n    currentScore: 0,\n    bestScore: 0,\n  },\n  gameStatus: false,\n};\n\nexport default initialState;\n","export const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\nexport const getRandomArrayItem = (array) => array[Math.floor(Math.random() * array.length)];\n\nexport const updateLocalEmpties = (emptyFields, oldTile, newTile) => emptyFields.map((item) => {\n  let emptyField = item;\n  if (item.colPos === oldTile.colPos && item.rowPos === oldTile.rowPos) {\n    emptyField = {\n      ...emptyField,\n      isEmpty: true,\n    };\n  }\n  if (item.colPos === newTile.colPos && item.rowPos === newTile.rowPos) {\n    emptyField = {\n      ...emptyField,\n      isEmpty: false,\n      tileVal: newTile.tileVal,\n    };\n  }\n  return emptyField;\n});\n\nexport const sortTilesForMove = (direction, tiles) => {\n  switch (direction) {\n    case 'left': {\n      return tiles.sort((a, b) => {\n        if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n        return a.colPos - b.colPos;\n      });\n    }\n    case 'right': {\n      return tiles.sort((a, b) => {\n        if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n        return b.colPos - a.colPos;\n      });\n    }\n    case 'up': {\n      return tiles.sort((a, b) => {\n        if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n        return a.colPos - b.colPos;\n      });\n    }\n    case 'down': {\n      return tiles.sort((a, b) => {\n        if (a.rowPos !== b.rowPos) return b.rowPos - a.rowPos;\n        return a.colPos - b.colPos;\n      });\n    }\n    default:\n      return [];\n  }\n};\n\n// export const sortTilesForMerge = (direction, tiles) => {\n//   switch (direction) {\n//     case 'left': {\n//       return tiles.sort((a, b) => {\n//         if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n//         return b.colPos - a.colPos;\n//       });\n//     }\n//     case 'right': {\n//       return tiles.sort((a, b) => {\n//         if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n//         return a.colPos - b.colPos;\n//       });\n//     }\n//     case 'up': {\n//       return tiles.sort((a, b) => {\n//         if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n//         return a.colPos - b.colPos;\n//       });\n//     }\n//     case 'down': {\n//       return tiles.sort((a, b) => {\n//         if (a.rowPos !== b.rowPos) return a.rowPos - b.rowPos;\n//         return a.colPos - b.colPos;\n//       });\n//     }\n//     default:\n//       return [];\n//   }\n// };\n","import {\n  ADD_TILE, ADD_RANDOM_TILE, INIT_FIRST_TILES,\n  UPDATE_POSITION, MERGE_TILES,\n} from '../actions';\nimport initialState from '../initialState';\nimport {\n  getRandomInt, updateLocalEmpties, getRandomArrayItem,\n  sortTilesForMove,\n} from '../../utilities';\n\nconst tilesReducer = (state = initialState.tiles, action) => {\n  switch (action.type) {\n    case ADD_RANDOM_TILE: {\n      const emptyFields = action.payload.filter(({ isEmpty }) => isEmpty === true);\n      const randomEmpty = getRandomArrayItem(emptyFields);\n      if (randomEmpty) {\n        return [\n          ...state,\n          {\n            rowPos: randomEmpty.rowPos,\n            colPos: randomEmpty.colPos,\n            tileVal: getRandomArrayItem([2, 4]),\n          },\n        ];\n      }\n      return state;\n    }\n    case ADD_TILE:\n      return state;\n    case INIT_FIRST_TILES: {\n      const initialTiles = [];\n\n      while (initialTiles.length < 2) {\n        const rowPosition = getRandomInt(1, 4);\n        const colPosition = getRandomInt(1, 4);\n        const tileValue = 2;\n\n        // Check if previous tile was created on the same place\n        const duplicate = initialTiles.find(\n          ({ rowPos, colPos }) => rowPos === rowPosition && colPos === colPosition,\n        );\n\n        if (!duplicate) {\n          initialTiles.push({\n            rowPos: rowPosition,\n            colPos: colPosition,\n            tileVal: tileValue,\n          });\n        }\n      }\n      return initialTiles;\n    }\n\n    // UPDATE_POSITION: moves all the tiles depends on the direction.\n    case UPDATE_POSITION: {\n      // Array of tiles sorts according to the move direction.\n      // It helps to move the right (first) tile first.\n      const sortedTiles = sortTilesForMove(action.payload.direction, state);\n      let tilesForRemove = [];\n\n      // Save the local empties\n      let { emptyFields } = action.payload;\n\n      const updatedTiles = sortedTiles.map((tile) => {\n        // switch is using cols or rows depend on the direction for every tile\n        const currentRow = emptyFields.filter(\n          ({ rowPos }) => rowPos === tile.rowPos,\n        );\n        const currentCol = emptyFields.filter(\n          ({ colPos }) => colPos === tile.colPos,\n        );\n        switch (action.payload.direction) {\n          case 'left': {\n            // Get the last possible FREE position for the tile in row to the left from its position\n            let prevCell = tile.colPos;\n            // -1 for the prev cell and -1 for the array iterator\n            let i = prevCell - 2 < 0 ? 0 : prevCell - 2;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i >= 0; i -= 1) {\n              if (currentRow[i].colPos !== tile.colPos && currentRow[i].isEmpty) {\n                prevCell = currentRow[i].colPos;\n              } else {\n                break;\n              }\n            }\n            // If there is a position and it's not the same that tile have\n            if (prevCell) {\n              // set new tile default value\n              let newTileValue = tile.tileVal;\n              // set position to the next cell after the cell to move tile\n              // to check the next cell is the same tile or not\n              const tileForMergePos = prevCell - 1;\n              // check if the next cell is not empty\n              const tileForMerge = emptyFields.find(\n                ({ rowPos, colPos, isEmpty }) => (\n                  colPos === tileForMergePos && rowPos === tile.rowPos && !isEmpty\n                ),\n              );\n\n              // if tile for merge was found and it's value the same as current tile\n              if (tileForMerge && tileForMerge.tileVal === tile.tileVal) {\n                // merged tile will me removed from state\n                tilesForRemove.push({\n                  rowPos: tileForMerge.rowPos,\n                  colPos: tileForMerge.colPos,\n                  tileVal: tileForMerge.tileVal,\n                });\n                // if tile was merged - set new tile position\n                prevCell = tileForMergePos;\n                // if tile was merged - set new tile value\n                newTileValue = tile.tileVal * 2;\n              }\n\n              // update local empties based on the new tile\n              emptyFields = updateLocalEmpties(\n                emptyFields, tile, { rowPos: tile.rowPos, colPos: prevCell, tileVal: newTileValue },\n              );\n\n              // Add new position and value (if was merged or default) for the tile\n              return {\n                ...tile,\n                colPos: prevCell,\n                tileVal: newTileValue,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          case 'right': {\n            // Get the last possible FREE position\n            // for the tile in row to the right from its position\n            let nextCell = tile.colPos;\n            // Index to start search\n            let i = nextCell;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i < 4; i += 1) {\n              if (currentRow[i].colPos !== tile.colPos && currentRow[i].isEmpty) {\n                nextCell = currentRow[i].colPos;\n              } else {\n                break;\n              }\n            }\n            // Update empties depends on the new tile position\n            if (nextCell) {\n              // set new tile default value\n              let newTileValue = tile.tileVal;\n              // set position to the next cell after the cell to move tile\n              // to check the next cell is the same tile or not\n              const tileForMergePos = nextCell + 1;\n              // check if the next cell is not empty\n              const tileForMerge = emptyFields.find(\n                ({ rowPos, colPos, isEmpty }) => (\n                  colPos === tileForMergePos && rowPos === tile.rowPos && !isEmpty\n                ),\n              );\n\n              // if tile for merge was found and it's value the same as current tile\n              if (tileForMerge && tileForMerge.tileVal === tile.tileVal) {\n                // merged tile will me removed from state\n                tilesForRemove.push({\n                  rowPos: tileForMerge.rowPos,\n                  colPos: tileForMerge.colPos,\n                  tileVal: tileForMerge.tileVal,\n                });\n                // if tile was merged - set new tile position\n                nextCell = tileForMergePos;\n                // if tile was merged - set new tile value\n                newTileValue = tile.tileVal * 2;\n              }\n\n              // update local empties based on the new tile\n              emptyFields = updateLocalEmpties(\n                emptyFields, tile, { rowPos: tile.rowPos, colPos: nextCell, tileVal: newTileValue },\n              );\n\n              // Add new position and value (if was merged or default) for the tile\n              return {\n                ...tile,\n                colPos: nextCell,\n                tileVal: newTileValue,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          case 'up': {\n            // Get the last possible FREE position for the tile in row above its position\n            let prevCell = tile.rowPos;\n            // -1 for the prev cell and -1 for the array iterator\n            let i = prevCell - 2 < 0 ? 0 : prevCell - 2;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i >= 0; i -= 1) {\n              if (currentCol[i].rowPos !== tile.rowPos && currentCol[i].isEmpty) {\n                prevCell = currentCol[i].rowPos;\n              } else {\n                break;\n              }\n            }\n\n            // Update empties depends on the new tile position\n            if (prevCell) {\n              let newTileValue = tile.tileVal;\n              const tileForMergePos = prevCell - 1;\n              const tileForMerge = emptyFields.find(\n                ({ rowPos, colPos, isEmpty }) => (\n                  colPos === tile.colPos && rowPos === tileForMergePos && !isEmpty\n                ),\n              );\n\n              if (tileForMerge && tileForMerge.tileVal === tile.tileVal) {\n                tilesForRemove.push({\n                  rowPos: tileForMerge.rowPos,\n                  colPos: tileForMerge.colPos,\n                  tileVal: tileForMerge.tileVal,\n                });\n                prevCell = tileForMergePos;\n                newTileValue = tile.tileVal * 2;\n              }\n\n              emptyFields = updateLocalEmpties(\n                emptyFields, tile, { rowPos: prevCell, colPos: tile.colPos, tileVal: newTileValue },\n              );\n\n              // Add new position for the tile\n              return {\n                ...tile,\n                rowPos: prevCell,\n                tileVal: newTileValue,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          case 'down': {\n            // Get the last possible FREE position for the tile in row below its position\n            let nextCell = tile.rowPos;\n            // -1 for the prev cell and -1 for the array iterator\n            let i = nextCell;\n            // Check every row field. If not the current tile\n            // && if is empty - save index, if not empty - return the last saved index\n            for (i; i < 4; i += 1) {\n              if (currentCol[i].rowPos !== tile.rowPos && currentCol[i].isEmpty) {\n                nextCell = currentCol[i].rowPos;\n              } else {\n                break;\n              }\n            }\n            // Update empties depends on the new tile position\n            if (nextCell) {\n              let newTileValue = tile.tileVal;\n              const tileForMergePos = nextCell + 1;\n              const tileForMerge = emptyFields.find(\n                ({ rowPos, colPos, isEmpty }) => (\n                  colPos === tile.colPos && rowPos === tileForMergePos && !isEmpty\n                ),\n              );\n\n              if (tileForMerge && tileForMerge.tileVal === tile.tileVal) {\n                tilesForRemove.push({\n                  rowPos: tileForMerge.rowPos,\n                  colPos: tileForMerge.colPos,\n                  tileVal: tileForMerge.tileVal,\n                });\n                nextCell = tileForMergePos;\n                newTileValue = tile.tileVal * 2;\n              }\n\n              emptyFields = updateLocalEmpties(\n                emptyFields, tile, { rowPos: nextCell, colPos: tile.colPos, tileVal: newTileValue },\n              );\n\n              // Add new position for the tile\n              return {\n                ...tile,\n                rowPos: nextCell,\n                tileVal: newTileValue,\n              };\n            }\n            // If there is no new position - return just unchanged tile\n            return tile;\n          }\n          default:\n            return tile;\n        }\n      });\n\n      return updatedTiles.filter((tile) => {\n        const removedVal = tilesForRemove.find(({ colPos, rowPos, tileVal }) => (\n          tile.colPos === colPos && tile.rowPos === rowPos && tile.tileVal === tileVal\n        ));\n        if (removedVal) {\n          return tile.rowPos !== removedVal.rowPos && tile.colPos !== removedVal.colPos;\n        }\n        return tile;\n      });\n    }\n    default:\n      return state;\n  }\n};\n\nexport default tilesReducer;\n","// Game actions\nexport const INIT_GAME = 'INIT_GAME';\nexport const FINISH_GAME = 'FINISH_GAME';\n\n// Empties actions\nexport const UPDATE_EMPTIES = 'UPDATE_EMPTIES';\nexport const INIT_EMPTIES = 'INIT_EMPTIES';\n\n// Tiles actions\nexport const UPDATE_POSITION = 'UPDATE_POSITION';\nexport const REMOVE_NUMBER = 'REMOVE_NUMBER';\nexport const ADD_TILE = 'ADD_TILE';\nexport const ADD_RANDOM_TILE = 'ADD_RANDOM_TILE';\nexport const INIT_FIRST_TILES = 'INIT_FIRST_TILES';\nexport const MERGE_TILES = 'MERGE_TILES';\n\n// Score actions\nexport const UPDATE_SCORE = 'UPDATE_SCORE';\nexport const CLEAR_CURRENT_SCORE = 'CLEAR_CURRENT_SCORE';\n","import { UPDATE_EMPTIES, INIT_EMPTIES } from '../actions';\r\nimport initialState from '../initialState';\r\n\r\nconst emptyFieldsReducer = (state = initialState.emptyFields, action) => {\r\n  switch (action.type) {\r\n    // UPDATE_EMPTIES: returns array of updated empty fields related to the sent tile.\r\n    // Find fields with old and new tile position.\r\n    // Set oldPosition.isEmpty to true, newPosition.isEmpty to false.\r\n    case UPDATE_EMPTIES: {\r\n      const tiles = action.payload;\r\n      const updatedEmpties = state.map((item) => {\r\n        const tile = tiles.find(\r\n          ({ rowPos, colPos }) => rowPos === item.rowPos && colPos === item.colPos,\r\n        );\r\n        if (tile) return { ...item, isEmpty: false };\r\n        return {\r\n          ...item,\r\n          isEmpty: true,\r\n        };\r\n      });\r\n      return updatedEmpties;\r\n    }\r\n    // INIT_EMPTIES: sets emptyFields to the default value.\r\n    case INIT_EMPTIES:\r\n      return initialState.emptyFields;\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nexport default emptyFieldsReducer;\r\n","import { UPDATE_SCORE, CLEAR_CURRENT_SCORE } from '../actions';\nimport initialState from '../initialState';\n\nconst scoreReducer = (state = initialState.score, action) => {\n  switch (action.type) {\n    case UPDATE_SCORE: {\n      let bestScoreValue = state.bestScore;\n      const currentScoreValue = state.currentScore + action.payload;\n      if (!bestScoreValue) {\n        bestScoreValue = action.payload;\n      } else {\n        bestScoreValue = Math.max(\n          currentScoreValue,\n          bestScoreValue,\n        );\n      }\n      return {\n        ...state,\n        currentScore: currentScoreValue,\n        bestScore: bestScoreValue,\n      };\n    }\n    case CLEAR_CURRENT_SCORE:\n      return {\n        ...state,\n        currentScore: initialState.score.currentScore,\n      };\n    default:\n      return state;\n  }\n};\n\nexport default scoreReducer;\n","import { INIT_GAME, FINISH_GAME } from '../actions';\nimport initialState from '../initialState';\n\nconst emptyFieldsReducer = (state = initialState.gameStatus, action) => {\n  switch (action.type) {\n    case INIT_GAME:\n      return true;\n    case FINISH_GAME:\n      return false;\n    default:\n      return state;\n  }\n};\n\nexport default emptyFieldsReducer;\n","import { combineReducers } from 'redux';\nimport tilesReducer from './tilesReducer';\nimport emptyFieldsReducer from './emptyFieldsReducer';\nimport scoreReducer from './scoreReducer';\nimport gameReducer from './gameReducer';\n\nexport default combineReducers({\n  tiles: tilesReducer,\n  emptyFields: emptyFieldsReducer,\n  score: scoreReducer,\n  gameStatus: gameReducer,\n});\n","import React from 'react';\n\n// CSS\nimport './styles.css';\n\nconst Field = () => (\n  <div className=\"grid\">\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n    <div className=\"grid-cell\" />\n  </div>\n);\n\nexport default Field;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\nconst Tile = ({ tileVal, rowPos, colPos }) => <div className={`number number--${tileVal} pos--${rowPos}-${colPos}`}>{tileVal}</div>;\n\nTile.propTypes = {\n  tileVal: PropTypes.number.isRequired,\n  rowPos: PropTypes.number.isRequired,\n  colPos: PropTypes.number.isRequired,\n};\n\nexport default Tile;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\n// redux\nimport { connect } from 'react-redux';\n\n// Components\nimport Tile from '../Tile';\n\nconst TilesField = ({ tiles }) => (\n  <div className=\"grid numbers\">\n    { tiles.map((tile) => <Tile key={`${tile.rowPos}-${tile.colPos}`} rowPos={tile.rowPos} colPos={tile.colPos} tileVal={tile.tileVal} />) }\n  </div>\n);\n\nTilesField.propTypes = {\n  tiles: PropTypes.arrayOf(PropTypes.objectOf(PropTypes.number)),\n};\n\nTilesField.defaultProps = {\n  tiles: [],\n};\n\nconst mapStateToProps = (state) => ({ tiles: state.tiles });\n\nexport default connect(mapStateToProps)(TilesField);\n","import { INIT_EMPTIES, UPDATE_EMPTIES } from '../actions';\n\nexport const initEmptiesAction = () => ({ type: INIT_EMPTIES });\nexport const updateEmptiesAction = (tiles) => ({ type: UPDATE_EMPTIES, payload: tiles });\n","import { INIT_GAME, FINISH_GAME } from '../actions';\nimport {\n  initTilesAction, updateTilesPositionAction, addRandomTileAction,\n  mergeTilesAction,\n} from './tilesActions';\nimport { clearScoreAction } from './scoreActions';\nimport { updateEmptiesAction, initEmptiesAction } from './emptiesAction';\n\nconst initGameAction = () => ({ type: INIT_GAME });\nconst finishGameAction = () => ({ type: FINISH_GAME });\n\nexport const initGameThunkAction = () => (dispatch, getState) => {\n  dispatch(initGameAction());\n  dispatch(clearScoreAction());\n  dispatch(initEmptiesAction());\n  dispatch(initTilesAction());\n  dispatch(updateEmptiesAction(getState().tiles));\n};\n\nexport const updateTilesPositionAThunk = (direction) => (dispatch, getState) => {\n  dispatch(updateTilesPositionAction(direction, getState().emptyFields));\n  dispatch(updateEmptiesAction(getState().tiles));\n\n  dispatch(addRandomTileAction(getState().emptyFields));\n  dispatch(updateEmptiesAction(getState().tiles));\n\n  // dispatch(mergeTilesAction(direction));\n  // dispatch(addRandomTileAction(getState().emptyFields));\n\n  // check game status\n  const freeEmpties = getState().emptyFields.filter(({ isEmpty }) => isEmpty);\n  if (!freeEmpties.length) {\n    dispatch(finishGameAction());\n  }\n};\n","import { UPDATE_SCORE, CLEAR_CURRENT_SCORE } from '../actions';\r\n\r\nexport const updateScoreAction = (currentScore) => ({\r\n  type: UPDATE_SCORE,\r\n  payload: currentScore,\r\n});\r\n\r\nexport const clearScoreAction = () => ({ type: CLEAR_CURRENT_SCORE });\r\n","import {\n  ADD_RANDOM_TILE, INIT_FIRST_TILES, UPDATE_POSITION,\n  MERGE_TILES,\n} from '../actions';\n\nexport const mergeTilesAction = (direction) => ({ type: MERGE_TILES, payload: direction });\n\nexport const initTilesAction = () => ({ type: INIT_FIRST_TILES });\n\nexport const addRandomTileAction = (emptyFields) => ({\n  type: ADD_RANDOM_TILE,\n  payload: emptyFields,\n});\n\nexport const updateTilesPositionAction = (direction, emptyFields) => ({\n  type: UPDATE_POSITION,\n  payload: {\n    direction,\n    emptyFields,\n  },\n});\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\n// CSS\r\nimport './styles.css';\r\n\r\n// redux\r\nimport { connect } from 'react-redux';\r\nimport { initGameThunkAction } from '../../Redux/actions/gameActions';\r\n\r\nconst StartButton = ({ initGame, children }) => <button type=\"button\" className=\"start-button\" onClick={initGame}>{ children }</button>;\r\n\r\nStartButton.propTypes = {\r\n  initGame: PropTypes.func.isRequired,\r\n  children: PropTypes.string,\r\n};\r\n\r\nStartButton.defaultProps = {\r\n  children: 'Start again',\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => ({\r\n  initGame: () => dispatch(initGameThunkAction()),\r\n});\r\n\r\nexport default React.memo(connect(undefined, mapDispatchToProps)(StartButton));\r\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\n// redux\nimport { connect } from 'react-redux';\n\nconst Score = ({ score, scoreType }) => {\n  const scoreLabel = scoreType === 'current' ? 'Your score' : 'Best score';\n  const scoreValue = scoreType === 'current' ? score.currentScore : score.bestScore;\n\n  return (\n    <div className=\"score\">\n      <span className=\"score__label\">{scoreLabel}</span>\n      <span className=\"score__value\">{scoreValue}</span>\n    </div>\n  );\n};\n\nScore.propTypes = {\n  score: PropTypes.objectOf(PropTypes.number).isRequired,\n  scoreType: PropTypes.string.isRequired,\n};\n\nconst mapStateToProps = (state) => ({ score: state.score });\n\nexport default React.memo(connect(mapStateToProps)(Score));\n","import React from 'react';\r\n\r\n// CSS\r\nimport './styles.css';\r\n\r\nimport StartButton from '../StartButton';\r\n\r\nconst FinishGame = () => (\r\n  <div className=\"game-status\">\r\n    END GAME\r\n    <StartButton>Restart</StartButton>\r\n  </div>\r\n);\r\n\r\nexport default React.memo(FinishGame);\r\n","import React, { useEffect } from 'react';\nimport { Swipeable } from 'react-swipeable';\nimport PropTypes from 'prop-types';\n\n// CSS\nimport './styles.css';\n\n// components\nimport { connect } from 'react-redux';\nimport Field from '../Field';\nimport TilesField from '../TilesField';\nimport StartButton from '../StartButton';\nimport Score from '../Score';\n\n// Actions\nimport { initGameThunkAction, updateTilesPositionAThunk } from '../../Redux/actions/gameActions';\nimport FinishGame from '../FinishGame';\n\nconst App = ({ initGame, updateTilesPosition, gameStatus }) => {\n  const moveLeft = () => {\n    updateTilesPosition('left');\n  };\n\n  const moveRight = () => {\n    updateTilesPosition('right');\n  };\n\n  const moveUp = () => {\n    updateTilesPosition('up');\n  };\n\n  const moveDown = () => {\n    updateTilesPosition('down');\n  };\n\n  useEffect(() => {\n    initGame();\n\n    document.addEventListener('keydown', (e) => {\n      switch (e.keyCode) {\n        case 37:\n          moveLeft();\n          break;\n        case 38:\n          moveUp();\n          break;\n        case 39:\n          moveRight();\n          break;\n        case 40:\n          moveDown();\n          break;\n        default:\n      }\n    });\n  }, []);\n\n  return (\n    <Swipeable\n      onSwipedLeft={moveLeft}\n      onSwipedRight={moveRight}\n      onSwipedUp={moveUp}\n      onSwipedDown={moveDown}\n      className=\"wrap\"\n    >\n      <h1 className=\"game-header\">2048</h1>\n      <p className=\"game-description\">Use Up, Down, Left, Right keys or swipe to play</p>\n      <StartButton />\n      <div className=\"score-wrap\">\n        <Score scoreType=\"current\" />\n        <Score scoreType=\"best\" />\n      </div>\n      <div className=\"game__container\">\n        <Field />\n        <TilesField />\n        { !gameStatus ? <FinishGame /> : null }\n      </div>\n    </Swipeable>\n  );\n};\n\nApp.propTypes = {\n  gameStatus: PropTypes.bool.isRequired,\n  initGame: PropTypes.func.isRequired,\n  updateTilesPosition: PropTypes.func.isRequired,\n};\n\nconst mapStateToProps = (state) => ({ tiles: state.tiles, gameStatus: state.gameStatus });\n\nconst mapDispatchToProps = (dispatch) => ({\n  initGame: () => dispatch(initGameThunkAction()),\n  updateTilesPosition: (direction) => dispatch(updateTilesPositionAThunk(direction)),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\n// CSS\nimport './css/variables.css';\nimport './css/common.css';\n\n// redux\nimport { applyMiddleware, compose, createStore } from 'redux';\nimport { Provider } from 'react-redux';\nimport thunkMiddleware from 'redux-thunk';\n\n// redux-persist\nimport { persistStore, persistReducer } from 'redux-persist';\nimport { PersistGate } from 'redux-persist/integration/react';\nimport storage from 'redux-persist/lib/storage';\nimport reducer from './Redux/reducers';\n\nimport App from './Components/App';\n\nconst persistConfig = {\n  key: 'root',\n  storage,\n};\n\nconst composeEnhancers = (\n  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n  && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({ trace: true, traceLimit: 25 })\n) || compose;\n\nconst persistedReducer = persistReducer(persistConfig, reducer);\nconst store = createStore(\n  persistedReducer,\n  composeEnhancers(applyMiddleware(thunkMiddleware)),\n);\n\nconst persistor = persistStore(store);\n\npersistor.purge(); // CLEAR redux-persist cache\n\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate persistor={persistor} loading={null}>\n      <App />\n    </PersistGate>\n  </Provider>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}